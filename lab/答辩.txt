老师好，我操作系统课程设计所完成的项目为6.S081的实验。
实验环境为阿里云的服务器，其中搭载的操作系统为Ubantu 20.04.2.
本次项目我一共完成了10个实验并通过这些实验对操作系统有了更深的了解，
接下来我会对我所完成的实验进行简单的介绍。

首先是第一个实验，第一个实验目的是熟悉xv6操作系统以及其系统调用。
其中sleep实现了对系统调用sleep添加用户级外壳进行调用。
pingpong利用fork()函数创建子进程并通过管道实现父子进程之间信息的传递。
primes也是通过管道和fork()函数实现了素数筛
find的实现与ls类似，相当于在ls的基础上找所需的文件，所以代码也可以在kernel
中的ls.c基础上进行修改，添加查找判断
xargs的作用是辅助其他指令，从标准读入中读取行并作为命令的参数进行执行，
考察了读入的处理以及exec函数

第二个实验让我掌握了如何编写系统调用。
当user文件夹中的程序需要调用系统调用时会通过ECALL指令传参给
kernel中的syscall函数，并通过它调用内核空间中的方法。
trace是为系统设置系统调用号，并在执行时检查其调用号，对检测到的
系统调用进行输出。
而sysinfo则是用于获得系统当前的可用进程数和可用内存，
其关键在于存在保存空闲内存块的链表，以及表示当前系统进程的数组
可以通过这个进行统计。

第三个实验是对页表的理解与运用。
print a page table顾名思义是对xv6页表机制中的三级页表进行递归输出
a kernel page table per process时通过修改内核使每个进程在执行时都使用自己的
内核页表副本。
而最后一个是通过替换copyin和copyinstr函数实现用户虚拟地址映射至内核页表，
实现直接访问的目的。

第四个实验主要涉及了内陷这一操作。
其中第一个直接生成汇编源码并根据其源码进行问题的回答，
其中涉及到通过内联函数进行优化
backtrace通过依靠栈帧地址指针的移动显示堆栈的调用情况
alarm进行了sigalarm以及sigreturn函数的实现，
其中sigalarm是经过固定的ticks执行handler函数，
令进程定时执行handler函数，
并通过sigreturn函数恢复中断前的寄存器状态

实验五让我学习到了惰性内存分配策略。
其中第一个实验让我简要了解到这种惰性内存分配是通过什么思路进行的，
即不分配物理内存，只记住分配了那些地址并将其在用户页中标记为无效。
lazy allocation实现了惰性分配，并处理缺页错误以及其导致的panic
lazytest and usertest是对惰性分配特殊情况的进一步处理

实验六主要考察了copy on write，即写时复制。
他会在各段内容要发生变化的时候才将父进程的内容复制给子进程，
减少了因为无意义的复制而导致的效率下降，让操作系统更加高效。
这里通过主要修改fork()函数使其满足上述要求。

实验七涉及到多线程。
Uthread实现了用户级的线程切换，包括了保存状态和恢复寄存器状态来进行线程的切换
Using threads是在真实的UNIX系统中通过对实验所提到的互斥锁完成多线程put中的加锁机制
达到互斥的目的。
Barrier可以看作一个同步问题，通过锁的运用实现在所有进程都调用barrier时才解锁所有的进程

实验八更进一步对锁进行了学习和应用。
其中Memory allocator实现了在多CPU中为每个CPU拆分一个空闲链表并单独进行管理
来降低锁冲突带来的额外开销。
Buffer cache则是解决了多个进程密集使用文件系统时征用bcache.lock的问题，
对磁盘空间中的块号进行散列处理，用哈希表维护缓冲区并为其设计锁，
为缓冲块设置时间戳并根据时间戳大小进行释放。

实验九进一步考察了xv6中的文件管理与链接方式。
Large files是为了支持更大字节的文件格式对现有索引层数进行改变。
xv6索引节点包含12个“直接”块编号和一个“单间接”块编号，
这是指最多容纳256个以上块编号的块，总共12 + 256 = 268 块，
现在要更改使每个inode中支持“双重间接”块，
其中包含256个单间接块地址，每个间接块最多可以包含256个数据块地址。 
结果将是一个文件最多可以包含65803个块或256 * 256 + 256 + 11个块。
接下来Symbolic links，即软连接，是通过路径名引用链接的文件。
当打开符号链接时，内核将链接指向引用的文件。 
符号链接类似于硬链接，但是硬链接仅限于指向同一磁盘上的文件，
而符号链接可以跨磁盘设备

最后一个，实验十对文件映射进行了考察。
mmap和munmap系统调用允许UNIX程序对其地址空间进行详细控制。 
它们可用于在进程之间共享内存，将文件映射到进程地址空间，
以及作为用户级页面错误方案的一部分。
mmap可以通过多种方式调用，但本实验仅需要与内存映射文件相关的部分功能。
最终实现mmap以及munmap函数及其功能
